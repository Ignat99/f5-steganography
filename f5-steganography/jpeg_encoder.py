#!/usr/bin/env python
# coding: utf-8


# Символы Юникод

import Image
import math
import operator
import logging

from util import PythonF5Random as F5Random
from util import Permutation
from util import BreakException
from util import EmbedData
from util import JPEG_NATURAL_ORDER
from util import create_array
from util import FilteredCollection

from huffman import Huffman
from DCT import DCT

logger = logging.getLogger('jpeg_encoder')

def eight_byte(first, second):
    return (first << 4) + second

# Autogenerated with DRAKON Editor 1.31
class JpegEncoder(object):


    def __init__(self, image, quality, out, comment):
        #item 72
        self.quality = quality
        self.jpeg_obj = JpegInfo(image, comment)
        
        self.image_width, self.image_height = image.size
        self.out = out
        
        self.dct = DCT(self.quality)
        self.huf = Huffman(*image.size)


    def _get_coeff(self):
        #item 80
        dct_array1 = create_array(0.0, 8, 8)
        dct_array2 = create_array(0.0, 8, 8)
        dct_array3 = create_array(0, 64)
        
        coeff = []
        for r in range(min(self.jpeg_obj.block_height)):
            for c in range(min(self.jpeg_obj.block_width)):
                #item 97
                xpos = c * 8
                ypos = r * 8
                for comp in range(self.jpeg_obj.comp_num):
                    #item 382
                    indata = self.jpeg_obj.components[comp]
                    maxa = self.image_height / 2 * self.jpeg_obj.vsamp_factor[comp] - 1
                    maxb = self.image_width / 2 * self.jpeg_obj.hsamp_factor[comp] - 1
                    for i in range(self.jpeg_obj.vsamp_factor[comp]):
                        for j in range(self.jpeg_obj.hsamp_factor[comp]):
                            #item 387
                            ia = ypos * self.jpeg_obj.vsamp_factor[comp] + i * 8
                            ib = xpos * self.jpeg_obj.hsamp_factor[comp] + j * 8
                            for a in range(8):
                                for b in range(8):
                                    #item 393
                                    dct_array1[a][b] = indata[min(ia+a, maxa)][min(ib+b, maxb)]
                            #item 388
                            dct_array2 = self.dct.forward_dct(dct_array1)
                            dct_array3 = self.dct.quantize_block(dct_array2, self.jpeg_obj.qtable_number[comp])
                            coeff.extend(dct_array3[:64])
        #item 379
        return coeff


    def compress(self, embedded_data=None, password='abc123'):
        #item 170
        self.embedded_data = EmbedData(embedded_data) if embedded_data else None
        self.password = password
        
        self.write_headers()
        self.write_compressed_data()
        self.write_eoi()
        self.out.flush()


    def get_quality(self):
        #item 321
        return self.quality


    def get_ycc_array(self):
        #item 313
        max_hsamp_factor = max(self.hsamp_factor)
        max_vsamp_factor = max(self.vsamp_factor)
        for i in range(self.comp_num):
            #item 342
            self.comp_width[i] = int(math.ceil(self.image_width / 8.0) * 8)
            self.comp_width[i] = self.comp_width[i] / max_hsamp_factor * self.hsamp_factor[i]
            self.block_width[i] = int(math.ceil(self.comp_width[i] / 8.0))
            
            self.comp_height[i] = int(math.ceil(self.image_height / 8.0) * 8)
            self.comp_height[i] = self.comp_height[i] / max_vsamp_factor * self.vsamp_factor[i]
            self.block_height[i] = int(math.ceil(self.comp_height[i] / 8.0))
        #item 343
        values = self.pixels
        Y  = create_array(0, self.comp_height[0], self.comp_width[0])
        Cb = create_array(0, self.comp_height[0], self.comp_width[0])
        Cr = create_array(0, self.comp_height[0], self.comp_width[0])
        for y in range(self.image_height):
            for x in range(self.image_width):
                #item 348
                r, g, b = values[x, y]
                Y[y][x]  =  0.299   * r + 0.587   * g + 0.114   * b
                Cb[y][x] = -0.16874 * r - 0.33126 * g + 0.5     * b + 128
                Cr[y][x] =  0.5     * r - 0.41869 * g - 0.08131 * b + 128
        #item 349
        self.components = [Y, self.down_sample(Cb, 1), self.down_sample(Cr, 2)]


    def order_codes(self):
        #item 189
        k = 0
        while True:
            #item 192
            if True:
                pass
            else:
                break
            #item 197
            i = self.huffval[k]
            self.ehufco[i] = self.huffcode[k]
            self.ehufsi[i] = self.huffsize[k]
            k += 1
            #item 195
            if k >= self.lastk:
                #item 194
                break
            else:
                pass


    def set_quality(self, quality):
        #item 329
        self.quality = quality
        self.dct = DCT(quality)


    def write_array(self, data):
        #item 337
        length = ((data[2] & 0xff) << 8) + (data[3] & 0xff) + 2
        self.out.write(bytearray(data[:length]))


    def write_compressed_data(self):
        #item 207
        tmp = 0
        
        last_dc_value = create_array(0, self.jpeg_obj.comp_num)
        zero_array = create_array(0, 64)
        width, height = 0, 0
        
        min_block_width = min(self.jpeg_obj.block_width)
        min_block_height = min(self.jpeg_obj.block_height)
        
        logger.info('DCT/quantisation starts')
        logger.info('%d x %d' % (self.image_width, self.image_height))
        
        coeff = self._get_coeff()
        coeff_count = len(coeff)
        
        logger.info('got %d DCT AC/DC coefficients' % coeff_count)
        _changed, _embedded, _examined, _expected, _one, _large, _thrown, _zero = 0, 0, 0, 0, 0, 0, 0, 0
        shuffled_index = 0
        for i, cc in enumerate(coeff):
            #item 220
            if i % 64 == 0:
                #item 223
                continue
            else:
                pass
            #item 210
            if cc == 1 or cc == -1:
                #item 215
                _one += 1
            else:
                #item 397
                if cc == 0:
                    #item 216
                    _zero += 1
                else:
                    pass
        #item 214
        _large = coeff_count - _zero - _one - coeff_count / 64
        _expected = _large + int(0.49 * _one)
        
        logger.info('one=%d' % _one)
        logger.info('large=%d' % _large)
        
        logger.info('expected capacity: %d bits' % _expected)
        logger.info('expected capacity with')
        for i in range(1, 8):
            #item 231
            n = (1 << i) - 1
            changed = _large - _large % (n + 1)
            changed = (changed + _one + _one / 2 - _one / (n + 1)) / (n + 1)
            
            usable = (_expected * i / n - _expected * i / n % n) / 8
            #item 232
            if usable == 0:
                #item 235
                break
            else:
                pass
            #item 241
            logger.info('%s code: %d bytes (efficiency: %d.%d bits per change)' % ('default' if i == 1 else '(1, %d, %d)' % (n, i), usable, usable * 8 / changed, usable * 80 / changed % 10))
        #item 242
        if self.embedded_data is not None:
            pass
        else:
            #item 245
            logger.info('permutation starts')
            random = F5Random(self.password)
            permutation = Permutation(coeff_count, random)
            
            next_bit_to_embed = 0
            byte_to_embed = len(self.embedded_data)
            available_bits_to_embed = 0
            
            logger.info('Embedding of %d bits (%d+4 bytes)' % (byte_to_embed * 8 + 32, byte_to_embed))
            #item 400
            if byte_to_embed > 0x007fffff:
                #item 403
                byte_to_embed = 0x007ffff
            else:
                pass
            for i in range(1, 8):
                #item 252
                self.n = (1 << i) - 1
                usable = (_expected * i / self.n - _expected * i / self.n % self.n) / 8
                #item 225
                if usable < byte_to_embed + 4:
                    #item 228
                    break
                else:
                    pass
            #item 406
            k = i - 1
            self.n = (1 << k) - 1
            #item 4070000
            _sw4070000_ = self.n
            #item 4070001
            if _sw4070000_ == 0:
                #item 414
                logger.info('using default code, file will not fit')
                self.n = 1
            else:
                #item 4070002
                if _sw4070000_ == 1:
                    #item 415
                    logger.info('using default code')
                else:
                    #item 416
                    logger.info('using (1, %d, %d) code' % (self.n, k))
            #item 418
            byte_to_embed |= k << 24
            byte_to_embed ^= random.get_next_byte()
            byte_to_embed ^= random.get_next_byte() << 8
            byte_to_embed ^= random.get_next_byte() << 16
            byte_to_embed ^= random.get_next_byte() << 24
            
            next_bit_to_embed = byte_to_embed & 1
            byte_to_embed >>= 1
            available_bits_to_embed = 31
            _embedded += 1
            for i, shuffled_index in enumerate(permutation.shuffled):
                #item 421
                if shuffled_index % 64 == 0 or coeff[shuffled_index] == 0:
                    #item 424
                    continue
                else:
                    pass
                #item 425
                cc = coeff[shuffled_index]
                _examined += 1
                #item 426
                if cc > 0 and (cc & 1) != next_bit_to_embed:
                    #item 429
                    coeff[shuffled_index] -= 1
                    _changed +=1
                else:
                    #item 430
                    if cc < 0 and (cc & 1) == next_bit_to_embed:
                        #item 433
                        coeff[shuffled_index] += 1
                        _changed += 1
                    else:
                        pass
                #item 434
                if coeff[shuffled_index] != 0:
                    #item 438
                    if available_bits_to_embed == 0:
                        #item 442
                        if self.n > 1 or not self.embedded_data.available():
                            #item 445
                            break
                        else:
                            pass
                        #item 446
                        byte_to_embed = self.embedded_data.read()
                        byte_to_embed ^= random.get_next_byte()
                        available_bits_to_embed = 8
                    else:
                        pass
                    #item 441
                    next_bit_to_embed = byte_to_embed & 1
                    byte_to_embed >>= 1
                    available_bits_to_embed -= 1
                    _embedded += 1
                else:
                    #item 437
                    _thrown += 1
            #item 447
            if self.n > 1:
                #item 450
                try:
                                    is_last_byte = False
                                    filtered_index = FilteredCollection(permutation.shuffled[i+1:], lambda index: index % 64 and coeff[index])
                while True:
                    #item 452
                    if not is_last_byte:
                        pass
                    else:
                        break
                    #item 454
                    k_bits_to_embed = 0
                    for i in range(k):
                        #item 458
                        if available_bits_to_embed == 0:
                            #item 461
                            if not self.embedded_data.available():
                                #item 464
                                is_last_byte = True
                                break
                            else:
                                pass
                            #item 465
                            byte_to_embed = self.embedded_data.read()
                            byte_to_embed ^= random.get_next_byte()
                            available_bits_to_embed = 8
                        else:
                            pass
                        #item 466
                        next_bit_to_embed = byte_to_embed & 1
                        byte_to_embed >>= 1
                        available_bits_to_embed -= 1
                        k_bits_to_embed |= next_bit_to_embed << i
                        _embedded += 1
                    #item 457
                    code_word = filtered_index.offer(self.n)
                while True:
                    #item 468
                    if True:
                        pass
                    else:
                        break
                    #item 470
                    vhash = 0
                    for i, index in enumerate(code_word):
                        #item 473
                        if coeff[index] > 0:
                            #item 476
                            extracted_bit = coeff[index] & 1
                        else:
                            #item 477
                            extracted_bit = 1 - (coeff[index] & 1)
                        #item 478
                        if extracted_bit == 1:
                            #item 481
                            vhash ^= i + 1
                        else:
                            pass
                    #item 482
                    i = vhash ^ k_bits_to_embed
                    #item 483
                    if not i:
                        #item 486
                        break
                    else:
                        pass
                    #item 487
                    i -= 1
                    coeff[code_word[i]] += 1 if coeff[code_word[i]] < 0 else -1
                    _changed += 1
                    #item 488
                    if not coeff[code_word[i]]:
                        #item 491
                        _thrown += 1
                        code_word[i:i+1] = []
                        code_word.extend(filtered_index.offer(1))
                    else:
                        #item 492
                        break
                #item 451
                except FilteredCollection.ListNotEnough:
                                    pass
            else:
                pass
            #item 494
            if _examined > 0:
                #item 497
                logger.info('%d coefficients examined' % _examined)
            else:
                pass
            #item 498
            if _changed > 0:
                #item 501
                logger.info('%d coefficients changed (efficiency: %d.%d bits per change' % (_changed, _embedded / _changed, _embedded * 10 / _changed % 10))
            else:
                pass
            #item 502
            logger.info('%d coefficients thrown (zeroed)' % _thrown)
            logger.info('%d bits (%d bytes) embedded' % (_embedded, _embedded / 8))
        #item 503
        logger.info('starting hufman encoding')
        shuffled_index = 0
        for r in range(min_block_height):
            for c in range(min_block_width):
                for comp in range(self.jpeg_obj.comp_num):
                    for i in range(self.jpeg_obj.vsamp_factor[comp]):
                        for j in range(self.jpeg_obj.hsamp_factor[comp]):
                            #item 514
                            dct_array3 = coeff[shuffled_index:shuffled_index+64]
                            self.huf.huffman_block_encoder(self.out, dct_array3, last_dc_value[comp], self.jpeg_obj.dctable_number[comp], self.jpeg_obj.actable_number[comp])
                            last_dc_value[comp] = dct_array3[0]
                            shuffled_index += 64
        #item 515
        self.huf.flush_buffer(self.out)


    def write_eoi(self):
        #item 355
        EOI = [0xff, 0xD9]
        self.write_marker(EOI)


    def write_headers(self):
        #item 148
        SOI = [0xff, 0xD8]
        self.write_marker(SOI)
        JFIF = [0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 
                        0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 
                        0x00, 0x60, 0x00, 0x60, 0x00, 0x00]
        self.write_array(JFIF)
        comment = self.jpeg_obj.get_comment()
        #item 358
        if comment:
            #item 361
            length = len(comment) + 2
            COM = [0xff, 0xfe, length >> 8 & 0xff, length & 0xff]
            COM.extend(comment)
            self.write_array(COM)
        else:
            pass
        #item 362
        DQT = [0xff, 0xdb, 0x00, 0x84]
        for k in range(2):
            #item 163
            DQT.append(k)
            DQT.extend([self.dct.quantum[k][JPEG_NATURAL_ORDER[i]] for i in range(64)])
        #item 363
        self.write_array(DQT)
        
        SOF = [0xff, 0xc0, 0x00, 0x11, 
                self.jpeg_obj.precision, 
                self.jpeg_obj.image_height >> 8 & 0xff, 
                self.jpeg_obj.image_height & 0xff, 
                self.jpeg_obj.image_width >> 8 & 0xff, 
                self.jpeg_obj.image_width & 0xff, 
                self.jpeg_obj.comp_num]
        for i in range(self.jpeg_obj.comp_num):
            #item 164
            SOF.append(self.jpeg_obj.com_id[i])
            SOF.append(eight_byte(self.jpeg_obj.hsamp_factor[i], self.jpeg_obj.vsamp_factor[i]))
            SOF.append(self.jpeg_obj.qtable_number[i])
        #item 364
        self.write_array(SOF)
                
        DHT = [0xff, 0xc4, 0, 0]
        for i in range(4):
            #item 368
            DHT.extend(self.huf.BITS[i])
            DHT.extend(self.huf.VAL[i])
        #item 369
        DHT[2] = len(DHT) - 2 >> 8 & 0xff
        DHT[3] = len(DHT) - 2 & 0xff
        self.write_array(DHT)
        
        SOS = [0] * 14
        SOS = [0xff, 0xda, 0x00, 0x0c, self.jpeg_obj.comp_num]
        for i in range(self.jpeg_obj.comp_num):
            #item 374
            SOS.append(self.jpeg_obj.com_id[i])
            SOS.append(eight_byte(self.jpeg_obj.dctable_number[i], self.jpeg_obj.actable_number[i]))
        #item 253
        SOS.append(self.jpeg_obj.ss)
        SOS.append(self.jpeg_obj.se)
        SOS.append(eight_byte(self.jpeg_obj.ah, self.jpeg_obj.al))
        self.write_array(SOS)


    def write_marker(self, data):
        #item 178
        self.out.write(bytearray(data[:2]))


