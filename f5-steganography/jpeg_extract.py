#!/usr/bin/env python
# coding: utf-8


# Символы Юникод

from huffman_decode import HuffmanDecode
from util import PythonF5Random as F5Random
from util import BreakException
from util import Permutation
import logging

logger = logging.getLogger('jpeg_decoder')

# Autogenerated with DRAKON Editor 1.31
class JpegExtract(object):

    de_zig_zag = [
            0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 
            42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 
            40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 
            33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 
            61, 35, 36, 48, 49, 57, 58, 62, 63]


    def __init__(self, out, password):
        #item 72
        self.out = out
        self.password = password


    def cal_embedded_length(self, permutation, coeff):
        #item 170
        self.extracted_file_length = 0
        self.pos = -1
        i = 0
        while True:
            #item 350
            if i < 32:
                pass
            else:
                break
            #item 352
            self.pos += 1
            shuffled_index = permutation.get_shuffled(self.pos)
            #item 353
            if shuffled_index % 64 == 0:
                #item 356
                continue
            else:
                pass
            #item 357
            cc = coeff[shuffled_index - shuffled_index % 64 + self.de_zig_zag[shuffled_index % 64]]
            #item 358
            if cc == 0:
                #item 361
                continue
            else:
                #item 362
                if cc > 0:
                    #item 365
                    extracted_bit = cc & 1
                else:
                    #item 366
                    extracted_bit = 1 - (cc & 1)
            #item 367
            self.extracted_file_length |= extracted_bit << i
            i += 1
        #item 369
        self.extracted_file_length ^= self.f5random.get_next_byte()
        self.extracted_file_length ^= self.f5random.get_next_byte() << 8
        self.extracted_file_length ^= self.f5random.get_next_byte() << 16
        self.extracted_file_length ^= self.f5random.get_next_byte() << 24


    def extract(self, data):
        #item 313
        hd = HuffmanDecode(data)
        logger.info('huffman decoding starts')
        coeff = hd.decode()
        
        logger.info('permutation starts')
        self.f5random = F5Random(self.password)
        permutation = Permutation(len(coeff), self.f5random)
        logger.info('%d indices shuffled' % len(coeff))
        
        self.extracted_byte = 0
        self.available_extracted_bits = 0
        self.n_bytes_extracted = 0
        self.extracted_bit = 0
        
        logger.info('extraction starts')
        
        self.cal_embedded_length(permutation, coeff)
        k = (self.extracted_file_length >> 24) % 32
        n = (1 << k) - 1
        self.extracted_file_length &= 0x007fffff
        logger.info('length of embedded file: %d bytes' % self.extracted_file_length)
        while True:
            #item 370
            if n > 1:
                pass
            else:
                #item 416
                logger.info('default code used')
                while True:
                    #item 417
                    if self.pos < len(coeff):
                        pass
                    else:
                        break
                    #item 419
                    self.pos += 1
                    shuffled_index = permutation.get_shuffled(self.pos)
                    #item 420
                    if shuffled_index % 64 == 0:
                        #item 423
                        continue
                    else:
                        pass
                    #item 424
                    shuffled_index = shuffled_index - shuffled_index % 64 + self.de_zig_zag[shuffled_index % 64]
                    #item 425
                    if coeff[shuffled_index] == 0:
                        #item 428
                        continue
                    else:
                        pass
                    #item 429
                    if coeff[shuffled_index] > 0:
                        #item 432
                        extracted_bit = coeff[shuffled_index] & 1
                    else:
                        #item 433
                        extracted_bit = 1 - (coeff[shuffled_index] & 1)
                    #item 434
                    self.extracted_byte |= extracted_bit << self.available_extracted_bits
                    self.available_extracted_bits += 1
                    #item 435
                    if self.available_extracted_bits == 8:
                        #item 438
                        self.write_extracted_byte()
                        #item 439
                        if self.n_bytes_extracted == self.extracted_file_length:
                            #item 442
                            break
                        else:
                            pass
                    else:
                        pass
                break
            #item 343
            vhash = 0
            logger.info('(1, %d, %d) code used' % (n, k))
            try:
            #item 373
            if True:
                pass
            else:
                #item 349
                except BreakException:
                      pass
                break
            #item 377
            vhash = 0
            code = 1
            while True:
                #item 375
                if code <= n:
                    pass
                else:
                    break
                #item 378
                self.pos += 1
                #item 379
                if self.pos >= len(coeff):
                    #item 382
                    raise BreakException()
                else:
                    pass
                #item 383
                shuffled_index = permutation.get_shuffled(self.pos)
                #item 384
                if shuffled_index % 64 == 0:
                    #item 387
                    continue
                else:
                    pass
                #item 388
                shuffled_index = shuffled_index - shuffled_index % 64 + self.de_zig_zag[shuffled_index % 64]
                #item 389
                if coeff[shuffled_index] == 0:
                    #item 392
                    continue
                else:
                    pass
                #item 393
                if coeff[shuffled_index] > 0:
                    #item 396
                    extracted_bit = coeff[shuffled_index] & 1
                else:
                    #item 397
                    extracted_bit = 1 - (coeff[shuffled_index] & 1)
                #item 398
                if extracted_bit == 1:
                    #item 401
                    vhash ^= code
                else:
                    pass
                #item 402
                code += 1
            for i in range(k):
                #item 406
                self.extracted_byte |= (vhash >> i & 1) << self.available_extracted_bits
                self.available_extracted_bits += 1
                #item 407
                if self.available_extracted_bits == 8:
                    #item 410
                    self.write_extracted_byte()
                    #item 411
                    if self.n_bytes_extracted == self.extracted_file_length:
                        #item 414
                        raise BreakException()
                    else:
                        pass
                else:
                    pass
        #item 444
        if self.n_bytes_extracted != self.extracted_file_length:
            #item 447
            logger.info('incomplete file: only %d of %d bytes extracted' % (self.n_bytes_extracted, self.extracted_file_length))
        else:
            pass


    def write_extracted_byte(self):
        #item 321
        self.extracted_byte ^= self.f5random.get_next_byte()
        self.out.write(chr(self.extracted_byte & 0xff))
        
        self.extracted_byte = 0
        self.available_extracted_bits = 0
        self.n_bytes_extracted += 1


