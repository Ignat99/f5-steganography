#!/usr/bin/env python
# coding: utf-8


# Символы Юникод

from util import EmbedData
from util import create_array
import logging
from haffman_table import HuffTable

logger = logging.getLogger('huffman_decode')

# Autogenerated with DRAKON Editor 1.31
class HuffmanDecode(object):

    APP = [0xe0, 0xe1, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef]
    DRI, DNL, EOI = 0xdd, 0xdc, 0xd9
    deZZ = [[0, 0], [0, 1], [1, 0], [2, 0], [1, 1], [0, 2], [0, 3], [1, 2], [2, 1], [3, 0], [4, 0], [3, 1], [2, 2], [1, 3], [0, 4], [0, 5], [1, 4], [2, 3], [3, 2], [ 4, 1 ], [ 5, 0 ], [ 6, 0 ], [ 5, 1 ], [ 4, 2 ], [ 3, 3 ], [ 2, 4 ], [ 1, 5 ], [ 0, 6 ], [ 0, 7 ], [ 1, 6 ], [ 2, 5 ], [ 3, 4 ], [ 4, 3 ], [ 5, 2 ], [ 6, 1 ], [ 7, 0 ], [ 7, 1 ], [ 6, 2 ], [ 5, 3 ], [ 4, 4 ], [ 3, 5 ], [ 2, 6 ], [ 1, 7 ], [ 2, 7 ], [ 3, 6 ], [ 4, 5 ], [ 5, 4 ], [ 6, 3 ], [ 7, 2 ], [ 7, 3 ], [ 6, 4 ], [ 5, 5 ], [ 4, 6 ], [ 3, 7 ], [ 4, 7 ], [ 5, 6 ], [ 6, 5 ], [ 7, 4 ], [ 7, 5 ], [ 6, 6 ], [ 5, 7 ], [ 6, 7 ], [ 7, 6 ], [ 7, 7 ] ]

    de_zig_zag = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 
            31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61,
            35, 36, 48, 49, 57, 58, 62, 63]


    def __init__(self, data, l):
        #item 72
        self.huffval = create_array([], 4)
        self.valptr = create_array([], 4)
        self.mincode = create_array([], 4)
        self.maxcode = create_array([], 4)
        self.zz = create_array(0, 64)
        self.qnt = create_array(0, 4, 64)
        
        self.data = EmbedData(data)
        self.size = len(self.data)
        self.ri = 0
        while True:
            #item 347
            if True:
                pass
            else:
                break
            #item 349
            if self.get_byte() == 255:
                #item 3400000
                _sw3400000_ = b = self.get_byte()
                #item 3400001
                if _sw3400000_ == 192:
                    #item 352
                    self.sof0()
                else:
                    #item 3400002
                    if _sw3400000_ == 196:
                        #item 353
                        self.dht()
                    else:
                        #item 3400003
                        if _sw3400000_ == 219:
                            #item 356
                            self.dqt()
                        else:
                            #item 3400004
                            if _sw3400000_ == 217:
                                #item 359
                                break
                            else:
                                #item 3400005
                                if _sw3400000_ == 218:
                                    #item 362
                                    break
                                else:
                                    #item 3400006
                                    if _sw3400000_ == self.DRI:
                                        #item 367
                                        self.dri()
                                    else:
                                        #item 368
                                        if b in self.APP:
                                            #item 363
                                            self.skip_variable()
                                        else:
                                            pass
            else:
                pass


    def _fill_value(self, index):
        #item 451
        ht = HuffTable(self.data, self.lh)
        self.lh -= ht.get_len()
        self.huffval[index] = ht.get_huffval()
        self.valptr[index] = ht.get_valptr()
        self.maxcode[index] = ht.get_maxcode()
        self.mincode[index] = ht.get_mincode()


    def _internal_decode(self):
        #item 189
        i, cd = 1, self.get_next_bit()
        while True:
            #item 192
            if cd > self.maxcode[self.hftbl][i]:
                pass
            else:
                break
            #item 197
            cd = (cd << 1) + self.get_next_bit()
            i += 1
        #item 392
        j = self.valptr[self.hftbl][i]
        j += cd - self.mincode[self.hftbl][i]
        return self.huffval[self.hftbl][j]


    def available(self):
        #item 170
        return self.data.available()


    def decode(self):
        #item 207
        pred = create_array(0, self.nf)
        self.CNT = 0
        self.ls = self.get_int()
        self.ns = self.get_byte()
        
        cs = create_array(0, self.ns)
        td = create_array(0, self.ns)
        ta = create_array(0, self.ns)
        for k in range(1, 64):
            #item 231
            cs[lp] = self.get_byte()
            td[lp], ta[lp] = self.get_double_four_bits()
        #item 224
        self.ss = self.get_byte()
        self.se = self.get_byte()
        self.ah, self.al = self.get_double_four_bits()
        
        buff = create_array(0, 2 * 8 * 8 * self.get_block_count())
        pos, mcu_count = 0, 0
        while True:
            #item 210
            if tmp:
                pass
            else:
                break
            for n_comp in range(0, self.nf):
                for cnt in range(self.h[n_comp] * self.v[n_comp]):
                    #item 215
                    self.hftbl = td[n_comp] * 2
                    tmp = self._internal_decode()
                    self.diff = self.receive(tmp)
                    self.zz[0] = pred[0] + self.extend(self.diff, tmp)
                    pred[n_comp] = self.zz[0]
                    
                    self.hftbl = ta[n_comp] * 2 + 1
                    self.decode_ac_coefficients()
                    for lp in range(64):
                        #item 435
                        buff[pos] = self.zz[lp]
                        pos += 1
            #item 436
            mcu_count += 1
            #item 242
            if mcu_count == self.ri:
                #item 245
                mcu_count = 0
                self.CNT = 0
                pred[n_comp] = create_array(0, self.nf)
                
                self.get_byte()
                tmp_b = self.get_byte()
                #item 225
                if tmp_b == EOI:
                    #item 228
                    break
                else:
                    pass
            else:
                pass
            #item 220
            if self.available() <= 2:
                #item 213
                if self.available() == 2:
                    #item 212
                    self.get_byte()
                    #item 232
                    if self.get_byte() != self.EOI:
                        #item 235
                        logger.error('file does not end with EOI')
                    else:
                        pass
                else:
                    #item 437
                    if self.available() == 1:
                        #item 440
                        logger.error('last byte: %X' % self.get_byte())
                    else:
                        pass
                    #item 441
                    logger.error('file does not end with EOI')
                #item 442
                break
            else:
                pass
        #item 443
        return buff[:pos]


    def decode_ac_coefficients(self):
        #item 292
        k = 1
        self.zz = [0] * 64
        while True:
            #item 295
            if True:
                pass
            else:
                break
            #item 299
            rs = self._internal_decode()
            ssss = rs % 16
            r = rs >> 4
            #item 298
            if ssss == 0:
                #item 424
                if r == 15:
                    #item 427
                    k += 16
                else:
                    #item 297
                    return
            else:
                #item 428
                k += r
                self.zz[k] = self.extend(self.receive(ssss), ssss)
                #item 303
                if k == 63:
                    #item 306
                    return
                else:
                    #item 307
                    k += 1


    def dht(self):
        #item 263
        self.lh = self.get_int()
        while True:
            #item 266
            if self.lh > 0:
                pass
            else:
                break
            #item 270
            self.tc, self.th = self.get_double_four_bits()
            #item 269
            if self.th == 0:
                #item 275
                if self.tc == 0:
                    #item 278
                    self._fill_value(0)
                else:
                    #item 454
                    self._fill_value(1)
            else:
                #item 283
                if self.tc == 0:
                    #item 286
                    self._fill_value(2)
                else:
                    #item 455
                    self._fill_value(3)


    def dqt(self):
        #item 461
        self.lq = self.get_int()
        self.pq, self.tq = self.get_double_four_bits()
        #item 464
        if self.tq in range(4):
            for lp in range(64):
                #item 469
                self.qnt[self.tq][lp] = self.get_byte()
        else:
            pass


    def dri(self):
        #item 475
        self.get_int()
        self.ri = self.get_int()


    def extend(self, v, t):
        #item 414
        if t == 0:
            #item 417
            return v
        else:
            pass
        #item 418
        vt = 0x01 << t - 1
        #item 419
        if v < vt:
            #item 422
            vt = (-1 << t) + 1
            v += vt
        else:
            pass
        #item 423
        return v


    def get_block_count(self):
        #item 337
        square = lambda x: x * x
        #item 3810000
        _sw3810000_ = self.nf
        #item 3810001
        if _sw3810000_ == 1:
            #item 388
            return square((self.x + 7) / 8)
        else:
            #item 3810002
            if _sw3810000_ == 3:
                #item 389
                return 6 * square((self.x + 15) / 16)
            else:
                #item 390
                logger.error('nf is not 1 neither 3')


    def get_byte(self):
        #item 313
        return self.data.read()


    def get_double_four_bits(self):
        #item 178
        b = self.get_byte()
        return b >> 4, b & 0x0f


    def get_int(self):
        #item 321
        return (self.get_byte() << 8) ^ self.get_byte()


    def get_next_bit(self):
        #item 372
        if not self.CNT:
            #item 375
            self.CNT = 8
            self.B = self.get_byte()
            #item 376
            if self.B == 255:
                #item 379
                self.get_byte()
            else:
                pass
        else:
            pass
        #item 380
        BIT = self.B & 0x80
        BIT >>= 7
        self.CNT -= 1
        self.B <<= 1
        return BIT


    def get_table_data(self):
        #item 148
        count = 0
        for x in range(1, 17):
            #item 163
            self.bits[x] = self.get_byte()
            count += self.bits[x]
        for x in range(0, count):
            #item 164
            self.huffval[x] = self.get_byte()
        #item 253
        return count


    def receive(self, sss):
        #item 398
        v, i = 0, 0
        while True:
            #item 401
            if i != sss:
                pass
            else:
                break
            #item 403
            i += 1
            v = (v << 1) + self.get_next_bit()
        #item 405
        return v


    def skip_variable(self):
        for i in range(self.get_int() - 2):
            #item 483
            self.get_byte()


    def sof0(self):
        #item 80
        self.lf = self.get_int()
        self.p = self.get_byte()
        self.y = self.get_int()
        self.x = self.get_int()
        self.nf = self.get_byte()
                
        self.c = create_array(0, self.nf)
        self.h = create_array(0, self.nf)
        self.v = create_array(0, self.nf)
        self.t = create_array(0, self.nf)
        for lp in range(self.nf):
            #item 97
            self.c[lp] = self.get_byte()
            self.h[lp], self.v[lp] = self.get_double_four_bits()
            self.t[lp] = self.get_byte()


